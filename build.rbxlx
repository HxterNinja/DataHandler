<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="29">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="CollisionGroups">Default^0^1</string>
			<Ref name="CurrentCamera">RBXCB657C72E5684DDA856FE22E3AFCEE7F</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<bool name="FilteringEnabled">true</bool>
			<float name="Gravity">196.199997</float>
			<token name="LevelOfDetail">0</token>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TemporaryLegacyPhysicsSolverOverrideStreaming">false</bool>
			<bool name="TerrainWeldsFixed">true</bool>
		</Properties>
		<Item class="Camera" referent="RBXCB657C72E5684DDA856FE22E3AFCEE7F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>20</Y>
					<Z>20</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>-0</R02>
					<R10>-0</R10>
					<R11>0.780868828</R11>
					<R12>0.624695063</R12>
					<R20>0</R20>
					<R21>-0.624695063</R21>
					<R22>0.780868828</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>0</X>
					<Y>0</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Part" referent="30">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-10</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284636770</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Baseplate</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>512</X>
					<Y>20</Y>
					<Z>512</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX2A8D71728F3D4DC1895668C672B76D04">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="22">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX8585DE3BB1024664AA5C2D16056950E9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXD115733266D844DBBD70F1C9B39B7F29">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX513ED410E631483F93845581B39CDBC9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX0BBFA5895B0C4D269FD28C71EF3FFCE1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX62E73430EBD341F4A2F4E7061261CF0A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">false</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBX3076E280FAE44357B6EB681901CF8D2D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GLOBALS</string>
				<string name="ScriptGuid">{5E3047E6-D38A-48CD-9AF6-23A4588F7863}</string>
				<ProtectedString name="Source"><![CDATA[local G = {}

for _,property in pairs(script:GetChildren()) do
	G[property.Name] = property.Value
end

return G]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="BoolValue" referent="RBX5B3B0628904741979AFF501C8191FBA6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">DEBUG</string>
					<BinaryString name="Tags"></BinaryString>
					<bool name="Value">true</bool>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBXCFE168A6944048E5AE53E154DCD206D4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">GAMETITLE</string>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBXDEDF0D1F369446FD83026CBA2D554FEC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">PLACENAME</string>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBXFDA914501D31442F8CCCBE9B22F8EB3C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">VERSION</string>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value">0.0.1</string>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="TweenService" referent="RBXD83F61A72A9B4F3C914612ADF86731D2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PermissionsService" referent="RBX99CEEB353CED4A799D80875035A81882">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX623CF2AD6F124CE19BD5201B4FB3D02B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<bool name="EnableScriptCollabOnLoad">false</bool>
			<bool name="EnableScriptCollabVersionHistoryOnLoad">false</bool>
			<string name="Name">StudioData</string>
			<int64 name="SrcPlaceId">5542478664</int64>
			<int64 name="SrcUniverseId">1937085625</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="23">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<BinaryString name="Tags"></BinaryString>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterCharacterScripts" referent="24">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="StarterPlayerScripts" referent="25">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="26">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ClientData</string>
					<string name="ScriptGuid">{60747C3C-6A51-463E-BEBA-0E7AE655A272}</string>
					<ProtectedString name="Source"><![CDATA[----- GLOBALS -----

local G = require(game.ReplicatedFirst:WaitForChild("GLOBALS"))

----- Loaded Modules -----

local Remotes = require(game.ReplicatedStorage:WaitForChild("Remotes"))
local HelperFns = require(game.ReplicatedStorage:WaitForChild("HelperFns"))
local Variable = require(script:WaitForChild("Variable"))

----- Private Variables -----

local ACCESS_KEY = "SomeRandomKeyUsedForObjectAccess" -- Used to access the Variable Object instead of the Value
local getAllPlayerDataFn = Remotes.GetAllPlayerDataFn
local updatePlayerDataEv = Remotes.UpdatePlayerDataEv

----- Public Variables -----

local Player = game.Players.LocalPlayer

local ClientData = {}
ClientData.__index = ClientData

----- Private Functions -----

--[[ 
	Description: 
    	Function that returns a new Variable Object.
	Parameters:
    	defualtData(Optional): Default data used to set up the Variable Object with
		_debug(Optional): Used to debug where the creation is coming from
	Returns:
		Variable Object
]]
local function _CreateVariable(defaultData, _debug)
	if _debug and G.DEBUG then
		print("Variable created: " .. _debug)
	end
	return Variable.new(defaultData)
end


--[[
	Description:
		Function that checks if the ClientData Object has the specified
			Variable Object in _privateVariableList or _publicVariableList
			and returns it.
		If not, will create a new Variable Object and return it.
	Parameters:
		variableName(Required): Name of the Variable used to locate Variable Object
		defaultData(Optional): Default data used to set up the Variable Object. Used only by ClientData:_Update() for now
]]
function ClientData:_GetVariableObject(variableName, defaultData)
	if self[ACCESS_KEY .. variableName] ~= nil then
		return self[ACCESS_KEY .. variableName]
	else
		self[variableName] = _CreateVariable(defaultData, "_GetVariableObject " .. variableName)
		return self[ACCESS_KEY .. variableName]
	end
end


--[[
	Description:
		Function called when a Variable's Value is being updated.
		This will fire all callback functions specified for ClientData.
	Parameters:
		variableName(Required): name of the Variable who's Value is being updated
		newData(Required): new value to set the Variable's Value to
]]
function ClientData:_Update(variableName, newData)
	local var = self:_GetVariableObject(variableName, newData)

	local oldVal = var.Value -- Store the old value for use in the ClientData callbacks
	var:_Update(newData) -- Updates the Variable, and fires its own callbacks
	local newVal = var.Value -- Get the new value for use in the ClientData callbacks

	for _,callback in pairs(self._callbacks) do
		callback(variableName, oldVal, newVal) -- Fire each callback function set up for ClientData
	end
end

----- Public Functions -----

--[[
	Description:
		Function that adds a callback function to the specified Variable Object, or
			the ClientData Object as a whole.
		These functions are called when the Variable Object's _Update function is
			called to change its data.
	Parameters:
		variableName(Required): the name of the variable you want to add a callback to
		func(Required): the function to be added
	WARNING:
		If no variableName is specified, and the function is the first parameter
			then you are specifying that you want to know any time that
			ClientData is being updated for any reason.
]]
function ClientData:OnUpdate(variableName, func)
	if type(variableName) == "function" then -- Check if want to encompas all Variables
		table.insert(self._callbacks, variableName) -- Insert function into callbacks for the ClientData Object
	else
		local var = self:_GetVariableObject(variableName)
		if var ~= nil then
			var:OnUpdate(func)
		end
	end
end

----- Initialize -----

local function initialize()
	local self = {}

	----- Private Variables -----
	--[[
		Description:
			A table used to store data the server will be manipulating

			(Read-Only) for the Client
			
			Server is the only entity with access to change data here
			See MasterData:GetDefaultData() for more information
	]]
	local _privateVariableList = {
	--[[
		WARNING!!!
		DO NOT PUT ANYTHING HERE!!!
		THIS IS JUST AN EXAMPLE OF HOW IT WILL LOOK!!

		Coins = _CreateVariable(_allData.Coins),
		Items = _CreateVariable(_allData.Items),
	]]
	}
	-- Setup all data that will be stored in _privateVariableList
	for dataName, data in pairs(getAllPlayerDataFn:InvokeServer()) do
		_privateVariableList[dataName] = _CreateVariable(data, "getAllPlayerData " .. dataName) -- Remove 2nd parameter if you don't want to debug
	end


	--[[
		Description:
			Similar to _privateVariableList, except this data is created and accessed
				by the Client only

			(Read-Write) for the Client

			Doesn't need to be set up right away, but in some cases having the index 
				at startup is needed
	]]
	local _publicVariableList = {
	--[[
		WARNING!!!
			Make sure the keys are different from _privateVariableList keys!!
			Check MasterData:GetDefaultData() for more information

		You can put whatever you want here at any
			time during the Client's session.

		These will never be saved and are usefull only for this session.

		Example Data:
		UIOpen = _CreateVariable({}),
		KillStreak = _CreateVariable({})
	]]
	}


	-- Table of callback functions fired when the ClientData table is updated
	self._callbacks = {}

	----- Public Variables -----



	----- Connections -----
	--[[
		Description:
			Connections is mainly used to listen to messages sent by the Server.

			As a default, we include an updatePlayerDataEv to check when the
				Server wants to update/add _privateVariableList Variables.

			I usually set them up as local variables in the Private Variables
				section at the very top. But this is not neccessary, you can
				just use 'Remotes.EventName.OnClientEvent' instead.
	]]

	-- Remote event fired when the Server is updating/adding a _privateVariableList Variable
	updatePlayerDataEv.OnClientEvent:Connect(function(variableName, newData)
		if _privateVariableList[variableName] == nil then -- Check if it doesn't exist and create a new Variable Object
			_privateVariableList[variableName] = _CreateVariable(newData, "_privateVariableList" .. variableName .. "")
		end
		self:_Update(variableName, newData)
	end)

	----- Metamethods -----

	--[[
		Description:
			When 'self' is indexed by anything, it first checks to see if
				the index is part of the ClientData table.

			This is useful so that you can call ClientData functions while
				still giving functionality to Variables inside the
				_privateVariableList and _publicVariableList by not having
				them be actual keys under 'self'. 
	]]
	self.__index = setmetatable(ClientData, {__index = function(tbl, index) -- First checks if ClientData has the index otherwise, fires this function
		if string.match(index, ACCESS_KEY) then -- Check if trying to access the Variable Object
			
			index = string.gsub(index, ACCESS_KEY, "")

			if _privateVariableList[index] ~= nil then
				return _privateVariableList[index]
			elseif _publicVariableList[index] ~= nil then
				return _publicVariableList[index]
			end
		elseif _privateVariableList[index] ~= nil then -- Check if trying to access private Variable Value
			return _privateVariableList[index].Value
		elseif _publicVariableList[index] ~= nil then -- Check if trying to access public Variable Value
			return _publicVariableList[index].Value
		end
	end})

	--[[
		Description:
			When attempting to setup or change a Variable's Value, this function will be called.
			
			It will attempt to locate the Variable within _privateVariableList or _publicVariableList,
				and based on which, will either warn that the client doesn't have access to change
				a Variable under the _privateVariableList table, or will change or create a new Variable Object
				and store it under the _publicVariableList.
	]]
	self.__newindex = function(tbl, index, newValue)
		if _privateVariableList[index] ~= nil then -- Check if the index is under the _privateVariableList
			warn("Attempting to change a Read-Only variable within ClientData!")
		elseif _publicVariableList[index] ~= nil then
			self:_Update(index, newValue)
		else
			_publicVariableList[index] = _CreateVariable(newValue, "_publicVariableList " .. index) -- Creates a new public Variable
		end
	end

	return setmetatable(self, self)
end

local m = initialize()
return m]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="27">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Variable</string>
						<string name="ScriptGuid">{69D44CEC-8397-4E0B-B89A-7D844CC8E357}</string>
						<ProtectedString name="Source"><![CDATA[local Variable = {}
Variable.__index = Variable

function Variable:OnUpdate(func)
	table.insert(self._callbacks, func)
end

function Variable:_Update(data)
	local oldVal = self.Value
	self.Value = data

	for _,func in pairs(self._callbacks) do
		func(oldVal, self.Value)
	end
end

function Variable.new(value)
	local self = setmetatable({}, Variable)

	self._callbacks = {}
	
	self.Value = value

	return self
end

return Variable]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="28">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ClientMain</string>
					<string name="ScriptGuid">{FCC7A3E6-31D4-4D9A-BA81-8C68DB87A64F}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	This is a test setup for handling ClientData
]]

local ClientData = require(script.Parent:WaitForChild("ClientData"))

print(ClientData.TestVariable)
ClientData.TestVariable = 5
print(ClientData.TestVariable)]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX5068DC6AC87141B3BFE182F3F30247BA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX8352DCED129C44E9B060762BF4C58D53">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX42F1FA6066FC4EFF9BE4A1A2D51ABB9E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX800EBFF3E6484B8CA20B82851F957841">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXE0D43D8560B14BA69486D1E5BE75ACFA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBXF55AF784DA034B298A35465EB9C1BF57">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX88B3F8D7560B4FA581B129E83CB5F5D3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX0E5B4169826744DA8B1275999590BDEA">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBXA1A403FED54D46FBBF5E326E96AAD501">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX335BAE19194345909A0E9E8050446F7B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX41A9C96A35AA4995B06EBD8AE29C8F46">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBXB4684F818EF6449693466C4C0FF31161">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXDC62C45C816342A5948687CD52B01E94">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXE171F90F583F48EDB0AE06CD358C9B11">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBXD9C6EAF781D0491CA5FB7EC5C186B314">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXF2A18F40846D4BCB8469795712C07D94">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBXE804C09005E64C54915F2F090F25E5E4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="13">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX0C3C3D23387B4BB99B59175F738D78F1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<string name="ScriptGuid">{26DEDBE3-7410-4DB1-9D4B-A8A729112F08}</string>
				<ProtectedString name="Source"><![CDATA[local G = require(game.ReplicatedFirst:WaitForChild("GLOBALS"))

print(("%s - v%s"):format(G.GAMETITLE, G.VERSION))
print(("Debug is %s."):format((G.DEBUG and "enabled" or "disabled")))

--Setup the PRNG.
math.randomseed(tick()) -- Must be called only one time per program.
math.random() -- Flush the first couple results to fix a known C/Lua bug.
math.random()
math.random()


-- The only things that should be run from Main are modules that are not loaded anywhere else.
-- These modules run their own init when loaded with "require"
local CoreLogic = require(script:WaitForChild("CoreLogic"))]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXE98756DDFBA74B44B24D749AD1134378">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CoreLogic</string>
					<string name="ScriptGuid">{B67C5D8F-F1D1-41CF-BB3F-4E83B6AE05EA}</string>
					<ProtectedString name="Source"><![CDATA[local G = require(game.ReplicatedFirst:WaitForChild("GLOBALS"))

local onPlayerAdded = require(script:WaitForChild("OnPlayerAdded"))
local onPlayerRemoving = require(script:WaitForChild("OnPlayerRemoving"))

local CoreLogic = {}

CoreLogic.__index = CoreLogic
setmetatable(CoreLogic, {
	__call = function(cls, ...)
		return cls.new(...)
	end
})


function CoreLogic.new()
	local self = setmetatable({}, CoreLogic)
	
	game.Players.PlayerAdded:Connect(onPlayerAdded)
	game.Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	-- Run the onPlayerAdded for any players who joined before the event handler was attached.
	for _,plr in pairs(game.Players:GetPlayers()) do
		onPlayerAdded(plr)
	end
	
	return self
end

-- NOTE: We are creating a single instance and returning it .
-- There must only be one instance of this module, ever.
local m = CoreLogic.new()
return m]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXFA6C69252FCE402AA3A46F86F2F0FC0A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">OnCharacterAdded</string>
						<string name="ScriptGuid">{97B3DEBF-AE61-4B62-BCE5-7AB17FCB881E}</string>
						<ProtectedString name="Source"><![CDATA[local G = require(game.ReplicatedFirst:WaitForChild("GLOBALS"))

local newOnPlayerDied = require(script.Parent:WaitForChild("OnPlayerDied"))

local function newOnCharacterAddedFn(plr)
	local function onCharacterAdded(chr)
		
		-- Find the humanoid, and detect when it dies
		local hum = chr:WaitForChild("Humanoid")
		if hum then
			hum.Died:Connect(newOnPlayerDied(plr))
		end
	end
	
	return onCharacterAdded
end

return newOnCharacterAddedFn]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7991D986873A4E4F9559E17D3609E271">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">OnPlayerAdded</string>
						<string name="ScriptGuid">{CC9F679F-1CE3-4D7A-9E31-DEB04039CF76}</string>
						<ProtectedString name="Source"><![CDATA[local G = require(game.ReplicatedFirst:WaitForChild("GLOBALS"))

local MasterData = require(game.ServerStorage:WaitForChild("MasterData"))
local newOnCharacterAddedFn = require(script.Parent:WaitForChild("OnCharacterAdded"))

local function onPlayerAdded(plr)
	MasterData:OnPlayerAdded(plr)

	local onCharacterAdded = newOnCharacterAddedFn(plr)
	plr.CharacterAdded:Connect(onCharacterAdded)
	
	plr:LoadCharacter()
end

return onPlayerAdded]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE68CD28BF9FE457786A86389070189E1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">OnPlayerDied</string>
						<string name="ScriptGuid">{A5203399-31DD-4691-9C3F-C05D1868F080}</string>
						<ProtectedString name="Source"><![CDATA[local G = require(game.ReplicatedFirst:WaitForChild("GLOBALS"))

local function newOnPlayerDied(plr)
	local function onPlayerDied()
		--Custom respawn functionality


		
		wait(5)
		plr:LoadCharacter()
	end
	
	return onPlayerDied
end

return newOnPlayerDied
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAEE5F053461941C292BF65968560B4F7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">OnPlayerRemoving</string>
						<string name="ScriptGuid">{352CD621-B388-4956-B387-91750A46E767}</string>
						<ProtectedString name="Source"><![CDATA[local G = require(game.ReplicatedFirst:WaitForChild("GLOBALS"))

local MasterData = require(game.ServerStorage:WaitForChild("MasterData"))

local function onPlayerRemoving(plr)
	MasterData:OnPlayerRemoving(plr)
end

return onPlayerRemoving]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="20">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="21">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MasterData</string>
				<string name="ScriptGuid">{DF526735-0B2A-4A42-8524-C148BE6E8D97}</string>
				<ProtectedString name="Source"><![CDATA[----- GLOBALS -----

local G = require(game.ReplicatedFirst:WaitForChild("GLOBALS"))

----- Loaded Modules -----

local ProfileService = require(game.ServerStorage:WaitForChild("ProfileService"))
local Remotes = require(game.ReplicatedStorage:WaitForChild("Remotes"))
local HelperFns = require(game.ReplicatedStorage:WaitForChild("HelperFns"))


--[[
	DATA MODULES:
		These are used to add functionality to your data. It also helps
			from cluttering up this script.

		There is a provided Template module that shows how to set up
			and use your own custom data types.

		WARNING:
			Make sure that you don't have multiple of the same public
			functions throughout all your DataModules.
			If you do, MasterData doesn't know what to call, and will
			fire the first one it comes by :/
]]
local DataModules = {}
for _,mod in pairs(script:GetChildren()) do
	DataModules[mod.Name] = require(mod) -- Itterate through every child module and add it to the list
end

----- Private Variables -----

local ProfileTemplate
local PlayerProfileStore

local DataVersion = "0.0.1"

local Profiles = {} -- [player] = profile


--[[
	Description:
		Sets up a metatable that when indexed, will first search through
		itself to find the index being referenced, otherwise it will search 
		through all DataModules until it finds the first matching index.
]]
local MasterData = setmetatable({}, {__index = function(tbl, index)
	print(index)

	local func
	for _,v in pairs(DataModules) do
		if v[index] then
			if type(v[index]) ~= "function" then -- Checks if the index is not a function
				return v[index]
			else
				func = v[index] -- Setup the function to be returned
				break
			end
		end
	end

	return function(_, plr, ...) -- Returns a function that calls func with plr, profile, ...
		if typeof(plr) == "Instance" and plr:IsA("Player") then -- Check if a Player is being passed to get the Profile
			local profile = Profiles[plr]
			func(_, plr, profile, ...)
		else
			func(_, plr, ...)
		end
	end
end})


local Players = game:GetService("Players")

----- Public Variables -----



----- Private Functions -----

--[[
	Description:
		Function that compares the profile with DataVersion and updates it accordingly
			if the profile is outdated
]]
local function CheckIfProfileNeedsUpdate(profile)
	if not profile:GetMetaTag("DataVersion") then
		-- First time setting up profile
		profile:SetMetaTag("DataVersion", DataVersion)
		print("New Player's Profile has been setup with DataVersion: " .. profile:GetMetaTag("DataVersion"))
	elseif profile:GetMetaTag("DataVersion") ~= DataVersion then
		--Remove unused/old data
		for dataName,_ in pairs(profile.Data) do
			if ProfileTemplate[dataName] == nil then
				profile.Data[dataName] = nil
				print("Removed " .. dataName)
			end
		end
		--Add in new data
		for dataName, defaultData in pairs(ProfileTemplate) do
			if profile.Data[dataName] == nil then
				profile.Data[dataName] = defaultData
			end
		end

		profile:SetMetaTag("DataVersion", DataVersion)
		print("Profile has been updated to new DataVersion: " .. profile:GetMetaTag("DataVersion"))
	end
end

----- Public Functions -----
--[[
	WARNING:
		ProfileService functionality that doesn't have to do with 'profile.Data' should
			should be handled here.

		You still have access to it 
]]



--[[
	Description:
		Function that gets the player's profile and returns its Data table.
	Returns:
		Table of player's profile data
]]
function MasterData:GetProfileData(plr)
	local profile = Profiles[plr]

	if profile then
		return profile.Data
	end
end

--[[
	Description:
		Function that returns a table with default data from all DataModule modules.
		Each module should have an _GetDefaultData function if it will be used to
			as a data type reference.
	Returns:
		Table of default data
]]
function MasterData:GetDefaultData()
	local defaultData = {
		--[[
			Place here any data you want saved that wont be set up
				through the DataModules.
		]]
	}

	for _,mod in pairs(DataModules) do -- Search through each DataModule
		if mod["_GetDefaultData"] then
			local dataName,default = mod:_GetDefaultData() -- Get the name of the data and its default value

			if type(dataName) == "table" and not default then -- If the name is a table
				for _dataName,_default in pairs(dataName) do -- Loop through the table for all name,default pairs
					defaultData[_dataName] = _default -- This is for data types with multiple variables associated with it
				end
			else
				defaultData[dataName] = default
			end
		end
	end

	return defaultData
end

--[[
	Description:
		Function called when a player is added to the game.
		This function handles the setup of the players Profile.
]]
function MasterData:OnPlayerAdded(plr)
	local profile = PlayerProfileStore:LoadProfileAsync(
		"Player_" .. plr.UserId,
		"ForceLoad"
	)

	if profile ~= nil then
		profile:ListenToRelease(function() -- Setup a Release listener for when the player's Profile is released
			Profiles[plr] = nil

			plr:Kick() -- Kick the player to prevent any data loss
		end)

		if plr:IsDescendantOf(Players) == true then -- Check if the player is a descendant of Players
			Profiles[plr] = profile

			CheckIfProfileNeedsUpdate(profile) -- Check if the player's profile needs to be updated
		else
			profile:Release() -- If the player left, release it's profile
		end
	else
		plr:Kick()
	end
end

--[[
	Description:
		Function called when a player is being removed from the game
]]
function MasterData:OnPlayerRemoving(plr)
	local profile = Profiles[plr]

	if profile ~= nil then -- If the player's profile exists in this server
		profile:Release() -- Release it
	end
end

----- Connections -----
--[[
	Description:
		Connections are used to recieve messages from the client and do something with it.

		I typically denote RemoteFunctions with an Fn at the end, and
			RemoteEvents with an Ev at the end so I know what I'm
			working with.
]]


--[[
	Description:
		Event Fired when the player is asking for All of its data.
	Returns:
		Table of player's Profile data
]]
Remotes.GetAllPlayerDataFn.OnServerInvoke = function(plr)
	local profile = Profiles[plr]

	if profile then
		return profile.Data
	end
end

----- Initialize -----

--[[
	We initialize this here so MasterData can get all setup before calling
	MasterData:GetDefaultData()
]] 
ProfileTemplate = MasterData:GetDefaultData()
PlayerProfileStore = ProfileService.GetProfileStore(
	"PlayerData",
	ProfileTemplate
)

return MasterData]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX8CC5BAEA0F1A4BD09E0B697563EFA05E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Template</string>
					<string name="ScriptGuid">{8DD922F1-89B7-41CC-AFE9-4BB10EE86DFA}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	This module is meant as a template for any data you are wanting to store and change in the server.
]]

----- Loaded Modules -----

local Remotes = require(game.ReplicatedStorage:WaitForChild("Remotes"))
local HelperFns = require(game.ReplicatedStorage:WaitForChild("HelperFns"))

----- Private Variables -----



----- Public Variables -----

local Template = {}
Template.__index = Template
----- Private Functions -----

--[[
	WARNING: THIS FUNCTION IS REQUIRED IF YOU WANT IT TO BE A PART OF THE DEFAULT DATA STRUCTURE
	Description:
		Function that returns the name and default data for this data type
]]
function Template:_GetDefaultData()
	local dataName = "Template"

	local defaultData = 5 
	--[[
		OR if there are multiple parts to this data structure then

		local dataName = {"Template Data Item 1", "Template Data Item 2"}

		local defaultData = {}
		defaultData["Template Data Item 1"] = "Temp1"
		defaultData["Template Data Item 2"] = "Temp2"

		Make sure your Keys are the same!!!
	]]

	return dataName, defaultData
end

--[[
	Description:
		Function called when the data of a player's profile is changed.
		Fires the UpdatePlayerEv function with the data name, and newData value
]]
local function _Update(plr, newData)
	Remotes.UpdatePlayerDataEv:FireClient(plr, "Template", newData)
end

----- Public Functions -----

--[[
	Description:
		Function that checks if the given profile's Template data is
			equal to otherData.
]]
function Template:TemplateFunc(plr, profile, otherData)
	local data = profile.Data
	if data.Template == otherData then
		print(plr)
	end
end

--[[
	Function to add a value to the player's Template value and update it
]]
function Template:AddToTemplate(plr, profile, amt)
	local data = profile.Data
	data.Template = data.Template + amt
	_Update(plr, data.Template)
end

--[[
	Function that generates a random number between startVal and endVal
]]
function Template:GenerateNewNumber(min, max)
	return math.random(min, max)
end

----- Initiate -----

return Template]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXC9CF40D5B3E546A78768C641A0EBE6DC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ProfileService</string>
				<string name="ScriptGuid">{E6FAD17D-A0DD-406D-BC33-0B42856EC059}</string>
				<ProtectedString name="Source"><![CDATA[--[[[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API
	
	Official documentation:
		https://madstudioroblox.github.io/ProfileService/
	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805
	
	WARNINGS FOR "Profile.Data" VALUES:
		More information on https://madstudioroblox.github.io/ProfileService/troubleshooting/
		! Do not store NaN values
	 	! Do not create array tables with non-sequential indexes - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.
	
	Functions:
	
		ProfileService.GetProfileStore(profile_store_name, profile_template) --> [ProfileStore]
		
		* Parameter description for "ProfileService.GetProfileStore()":
		
			profile_store_name   [string] -- DataStore name
			profile_template     []:
				{}                        [table] -- Profiles will default to given table (hard-copy) when no data was saved previously
				nil                       [nil] -- ProfileStore:LoadProfileAsync() method will be locked
		
	Methods [ProfileStore]:
	
		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile / nil] not_released_handler(place_id, game_job_id)
		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
		
		ProfileStore:ViewProfileAsync(profile_key) --> [Profile / nil] -- Notice #1: Profile object methods will not be available;
			Notice #2: Profile object members will be nil (Profile.Data = nil, Profile.MetaData = nil) if the profile hasn't
			been created, with the exception of Profile.GlobalUpdates which could be empty or populated by
			ProfileStore:GlobalUpdateProfileAsync()
		
		* Parameter description for "ProfileStore:LoadProfileAsync()":
		
			profile_key            [string] -- DataStore key
			not_released_handler = "ForceLoad" -- Force loads profile on first call
			OR
			not_released_handler   [function] (place_id, game_job_id) --> [string] ("Repeat" / "Cancel" / "ForceLoad")
				-- "not_released_handler" will be triggered in cases where the profile is not released by a session. This
				function may yield for as long as desirable and must return one of three string values:
					["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
					["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
					["ForceLoad"] - ProfileService will repeat the profile loading call while trying to make the owner game server
						release the profile. It will "steal" the profile ownership if the server doesn't release the profile in time.
						
		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":
		
			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)
		
	Members [Profile]:
	
		Profile.Data            [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData        [table] (Read-only) -- Information about this profile
		
			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after
				they pile up)
		
		Profile.GlobalUpdates   [GlobalUpdates]
		
	Methods [Profile]:
	
		-- SAFE METHODS - Will not error after profile expires:
		Profile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to
			
		Profile:GetMetaTag(tag_name) --> value
		
		Profile:ListenToRelease(listener) --> [ScriptConnection] () -- WARNING: Profiles can be released externally if another session
			force-loads this profile - use :ListenToRelease() to handle player leaving cleanup.
			
		Profile:Release() -- Call after the session has finished working with this profile
			e.g., after the player leaves (Profile object will become expired) (Does not yield)
		
		-- DANGEROUS METHODS - Will error if the profile is expired:
		-- MetaTags - Save and read values stored in Profile.MetaData for storing info about the
			profile itself like "Profile:SetMetaTag("FirstTimeLoad", true)"
		Profile:SetMetaTag(tag_name, value)
		
		Profile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)
		
	Methods [GlobalUpdates]:
	
	-- ALWAYS AVAILABLE:
		GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
		GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
		
	-- ONLY ACCESSIBLE THROUGH "Profile.GlobalUpdates":
		GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
		GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
		-- WARNING: GlobalUpdates:LockUpdate() and GlobalUpdates:ClearLockedUpdate() will error after profile expires
		GlobalUpdates:LockActiveUpdate(update_id)
		GlobalUpdates:ClearLockedUpdate(update_id)
		
	-- AVAILABLE INSIDE "update_handler" DURING A ProfileStore:GlobalUpdateProfileAsync() CALL
		GlobalUpdates:AddActiveUpdate(update_data)
		GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
		GlobalUpdates:ClearActiveUpdate(update_id)
		
--]]

local SETTINGS = {

	AutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)
	LoadProfileRepeatDelay = 15, -- Seconds between successive DataStore calls for the same key
	ForceLoadMaxSteps = 4, -- Steps taken before ForceLoad request steals the active session for a profile
	
	IssueCountForCriticalState = 5, -- Issues to collect to announce critical state
	IssueLast = 120, -- Seconds
	CriticalStateLast = 120, -- Seconds
	
}

----- Service Table -----

local ProfileService = {

	ServiceLocked = false, -- Set to true once the server is shutting down - Calling ProfileService functions afterwards will result in an error
	
	IssueSignal = nil, -- [ScriptSignal] (error_message) -- Fired when a DataStore API call throws an error
	CorruptionSignal = nil,  -- [ScriptSignal] (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has
		-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a non table value
	
	CriticalState = false, -- Set to true while DataStore service is throwing too many errors
	CriticalStateSignal = nil, -- [ScriptSignal] (is_critical_state) -- Fired when CriticalState is set to true
		-- (You may alert players with this, or set up analytics)
	
	ServiceIssueCount = 0,

	_active_profile_stores = {
		--[[
			{
				_profile_store_name = "", -- [string] -- DataStore name
				_profile_template = {} / nil, -- [table / nil]
				_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
				
				_loaded_profiles = {
					[profile_id] = {
						Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
						MetaData = {}, -- [table] -- Updated with every auto-save
						GlobalUpdates = {, -- [GlobalUpdates]
							_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
							_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
							_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
							
							_new_active_update_listeners = {listener, ...} / nil, -- [table / nil]
							_new_locked_update_listeners = {listener, ...} / nil, -- [table / nil]
							
							_profile = Profile / nil, -- [Profile / nil]
							
							_update_handler_mode = true / nil, -- [bool / nil]
						}
						
						_id = 1 / nil, -- [number / nil]
						_profile_store = ProfileStore, -- [ProfileStore]
						_profile_key = "", -- [string]
						
						_release_listeners = {listener, ...} / nil, -- [table / nil]
						
						_view_mode = true / nil, -- [bool / nil]
						
						_load_timestamp = tick(),
					},
					...
				},
				_profile_load_jobs = {["profile_key"] = true, ...},
			},
			...
		--]]
	},
	
	_auto_save_list = { -- loaded profile table which will be circularly auto-saved
		--[[
			Profile,
			...
		--]]
	},
	
	_issue_queue = {}, -- [table] {issue_tick, ...}
	_critical_state_start = 0, -- [number] 0 = no critical state / tick() = critical state start
	
}

--[[
	Saved profile structure:
	
	DataStoreProfile = {
		Data = {},
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			MetaTags = {},
		},
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
	
	OR
	
	DataStoreProfile = {
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
--]]

----- Private Variables -----

local ActiveProfileStores = ProfileService._active_profile_stores
local AutoSaveList = ProfileService._auto_save_list
local IssueQueue = ProfileService._issue_queue

local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = tick()

local ProfileIndex = 0
local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- tick()

local IsStudio = RunService:IsStudio()
local FakeDataStore -- For studio testing

----- Utils -----

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

-- I wanted this module to be stand-alone, so I hardcoded the script connection and signal objects
-- ScriptConnection object:

local ScriptConnection = {
	-- _listener = function -- [function]
	-- _listener_table = {} -- [table] -- Table from which the function entry will be removed
}

function ScriptConnection:Disconnect()
	local listener = self._listener
	if listener ~= nil then
		local listener_table = self._listener_table
		for i = 1, #listener_table do
			if listener == listener_table[i] then
				table.remove(listener_table, i)
				break
			end
		end
		self._listener = nil
	end
end

function ScriptConnection.NewScriptConnection(listener_table, listener) --> [ScriptConnection]
	return {
		_listener = listener,
		_listener_table = listener_table,
		Disconnect = ScriptConnection.Disconnect
	}
end

-- ScriptSignal object:

local ScriptSignal = {
	-- _listeners = {}
}

function ScriptSignal:Connect(listener) --> [ScriptConnection]
	if type(listener) ~= "function" then
		error("[ScriptSignal]: Only functions can be passed to ScriptSignal:Connect()")
	end
	table.insert(self._listeners, listener)
	return {
		_listener = listener,
		_listener_table = self._listeners,
		Disconnect = ScriptConnection.Disconnect
	}
end

function ScriptSignal:Fire(...)
	for _, listener in ipairs(self._listeners) do
		listener(...)
	end
end

function ScriptSignal.NewScriptSignal() --> [ScriptSignal]
	return {
		_listeners = {},
		Connect = ScriptSignal.Connect,
		Fire = ScriptSignal.Fire
	}
end

----- Private functions -----

local function RegisterIssue(error_message) -- Called when a DataStore API call errors
	warn("[ProfileService]: DataStore API error - \"" .. tostring(error_message) .. "\"")
	table.insert(IssueQueue, tick()) -- Adding issue time to queue
	ProfileService.IssueSignal:Fire(tostring(error_message))
end

local function RegisterCorruption(profile_store_name, profile_key) -- Called when a corrupted profile is loaded
	warn("[ProfileService]: Profile corruption - ProfileStore = \"" .. profile_store_name .. "\", Key = \"" .. profile_key .. "\"")
	ProfileService.CorruptionSignal:Fire(profile_store_name, profile_key)
end

local function FakeUpdateAsync(profile_store_name, key, transform_function)
	local profile_store = FakeDataStore[profile_store_name]
	if profile_store == nil then
		profile_store = {}
		FakeDataStore[profile_store_name] = profile_store
	end
	local transform = transform_function(profile_store[key])
	if transform == nil then
		return nil
	else
		profile_store[key] = DeepCopyTable(transform)
		return DeepCopyTable(profile_store[key])
	end
end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

--[[
update_settings = {
	ExistingProfileHandle = function(latest_data),
	MissingProfileHandle = function(latest_data),
	EditProfile = function(lastest_data)
}
--]]
local function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings)
	local loaded_data
	local success, error_message = pcall(function()
		local transform_function = function(latest_data)
			local missing_profile = false
			local data_corrupted = false
			local global_updates_data = {0, {}}
			
			if latest_data == nil then
				missing_profile = true
			elseif type(latest_data) ~= "table" then
				missing_profile = true
				data_corrupted = true
			end
			
			if type(latest_data) == "table" then
				-- Case #1: Profile was loaded
				if type(latest_data.Data) == "table" and
					type(latest_data.MetaData) == "table" and
					type(latest_data.GlobalUpdates) == "table" then
					
					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates
					if update_settings.ExistingProfileHandle ~= nil then
						update_settings.ExistingProfileHandle(latest_data)
					end
				-- Case #2: Profile was not loaded but GlobalUpdate data exists
				elseif latest_data.Data == nil and
					latest_data.MetaData == nil and
					type(latest_data.GlobalUpdates) == "table" then
					
					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates
					missing_profile = true
				else
					missing_profile = true
					data_corrupted = true
				end
			end
			
			-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates_data,
				}
				if update_settings.MissingProfileHandle ~= nil then
					update_settings.MissingProfileHandle(latest_data)
				end
			end
			
			-- Editing profile:
			if update_settings.EditProfile ~= nil then
				update_settings.EditProfile(latest_data)
			end
			
			-- Data corruption handling (Silently override with empty profile) (Also run Case #1)
			if data_corrupted == true then
				latest_data.WasCorrupted = true -- Temporary tag that will be removed on first save
			end
			
			return latest_data
		end
		if IsStudio == true then -- Dummy empty DataStore when running game in studio mode
			wait() -- Simulate API call yield
			loaded_data = FakeUpdateAsync(profile_store._profile_store_name, profile_key, transform_function)
		else
			loaded_data = profile_store._global_data_store:UpdateAsync(profile_key, transform_function)
		end
	end)
	if success == true and type(loaded_data) == "table" then
		-- Corruption handling:
		if loaded_data.WasCorrupted == true then
			RegisterCorruption(profile_store._profile_store_name, profile_key)
		end
		-- Return loaded_data:
		return loaded_data
	else
		RegisterIssue((error_message ~= nil) and error_message or "Undefined error")
		-- Return nothing:
		return nil
	end
end

local function RemoveProfileFromAutoSave(profile)
	local auto_save_index
	for i = 1, #AutoSaveList do
		if profile == AutoSaveList[i] then
			auto_save_index = i
			break
		end
	end
	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end
end

local function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon
	-- Add at AutoSaveIndex and move AutoSaveIndex right:
	table.insert(AutoSaveList, AutoSaveIndex, profile)
	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = tick()
	end
end

local function ReleaseProfileInternally(profile)
	-- 1) Remove profile object from ProfileService references: --
	-- Clear reference in ProfileStore:
	local profile_store = profile._profile_store
	local loaded_profiles = profile_store._loaded_profiles
	loaded_profiles[profile._id] = nil
	if next(loaded_profiles) == nil then -- ProfileStore has turned inactive
		local index = table.find(ActiveProfileStores, profile_store)
		if index ~= nil then
			table.remove(ActiveProfileStores, index)
		end
	end
	-- Clear auto update reference:
	RemoveProfileFromAutoSave(profile)
	-- 2) Trigger release listeners: --
	for _, listener in ipairs(profile._release_listeners) do
		listener()
	end
	profile._release_listeners = {}
end

local function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
	local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
	local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
	local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
	-- "old_" or "new_" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	for _, new_global_update in ipairs(new_global_updates_data[2]) do
		-- Find old global update with the same update_id:
		local old_global_update
		for _, global_update in ipairs(old_global_updates_data[2]) do
			if global_update[1] == new_global_update[1] then
				old_global_update = global_update
				break
			end
		end
		-- A global update is new when it didn't exist before or its version_id or update_locked state changed:
		local is_new = false
		if old_global_update == nil or new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then
			
			is_new = true
		end
		if is_new == true then
			-- Active global updates:
			if new_global_update[3] == false then
				-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)
				local is_pending_lock = false
				for _, update_id in ipairs(pending_update_lock) do
					if new_global_update[1] == update_id then
						is_pending_lock = true
						break
					end
				end
				if is_pending_lock == false then
					-- Trigger new active update listeners:
					for _, listener in ipairs(global_updates_object._new_active_update_listeners) do
						listener(new_global_update[1], new_global_update[4])
					end
				end
			end
			-- Locked global updates:
			if new_global_update[3] == true then
				-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)
				local is_pending_clear = false
				for _, update_id in ipairs(pending_update_clear) do
					if new_global_update[1] == update_id then
						is_pending_clear = true
						break
					end
				end
				if is_pending_clear == false then
					-- Trigger new locked update listeners:
					for _, listener in ipairs(global_updates_object._new_locked_update_listeners) do
						listener(new_global_update[1], new_global_update[4])
						-- Check if listener marked the update to be cleared:
						-- Normally there should be only one listener per profile for new locked global updates, but
						-- in case several listeners are connected we will not trigger more listeners after one listener
						-- marks the locked global update to be cleared.
						for _, update_id in ipairs(pending_update_clear) do
							if new_global_update[1] == update_id then
								is_pending_clear = true
								break
							end
						end
						if is_pending_clear == true then
							break
						end
					end
				end
			end
		end
	end
end

local function SaveProfileAsync(profile, release_from_session)
	if type(profile.Data) ~= "table" then
		RegisterCorruption(profile._profile_store._profile_store_name, profile._profile_key)
		error("[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! ProfileStore = \"" .. profile._profile_store._profile_store_name .. "\", Key = \"" .. profile._profile_key .. "\"")
	end
	if release_from_session == true then
		ReleaseProfileInternally(profile)
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1
	local loaded_data = StandardProfileUpdateAsyncDataStore(
		profile._profile_store,
		profile._profile_key,
		{
			ExistingProfileHandle = nil,
			MissingProfileHandle = nil,
			EditProfile = function(latest_data)
				-- 1) Check if this session still owns the profile: --
				local active_session = latest_data.MetaData.ActiveSession
				local session_owns_profile = false
				if type(active_session) == "table" then
					session_owns_profile = IsThisSession(active_session)
				end
				
				if session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile
					-- 2) Manage global updates: --
					local latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
					local latest_global_updates_list = latest_global_updates_data[2]
					
					local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
					local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
					local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
					-- Active update locking:
					for i = 1, #latest_global_updates_list do
						for _, lock_id in ipairs(pending_update_lock) do
							if latest_global_updates_list[i][1] == lock_id then
								latest_global_updates_list[i][3] = true
								break
							end
						end
					end
					-- Locked update clearing:
					for _, clear_id in ipairs(pending_update_clear) do
						for i = 1, #latest_global_updates_list do
							if latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then
								table.remove(latest_global_updates_list, i)
								break
							end
						end
					end
					-- 3) Save profile data: --
					latest_data.Data = profile.Data
					latest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData
					if release_from_session == true then
						latest_data.MetaData.ActiveSession = nil
					end
				end
			end,
		})
	if loaded_data ~= nil then
		-- 4) Set latest data in profile: --
		-- Setting global updates:
		local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
		local old_global_updates_data = global_updates_object._updates_latest
		local new_global_updates_data = loaded_data.GlobalUpdates
		global_updates_object._updates_latest = new_global_updates_data
		-- Setting MetaData:
		local keep_session_meta_tag_reference = profile.MetaData.MetaTags
		profile.MetaData = loaded_data.MetaData
		profile.MetaData.MetaTagsLatest = profile.MetaData.MetaTags
		profile.MetaData.MetaTags = keep_session_meta_tag_reference
		-- 5) Check if session still owns the profile: --
		local active_session = loaded_data.MetaData.ActiveSession
		local force_load_session = loaded_data.MetaData.ForceLoadSession
		local session_owns_profile = false
		local force_load_pending = false
		if type(active_session) == "table" then
			session_owns_profile = IsThisSession(active_session)
		end
		if type(force_load_session) == "table" then
			force_load_pending = not IsThisSession(force_load_session)
		end
		local is_active = profile._profile_store._loaded_profiles[profile._id] == profile
		if session_owns_profile == true then
			-- 6) Check for new global updates: --
			if is_active == true then -- Profile could've been released before the saving thread finished
				if force_load_pending == false then
					CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
				else
					-- Another game session is force loading this profile:
					SaveProfileAsync(profile, true) -- Call save function in a new thread with release_from_session = true
				end
			end
		else
			-- Session no longer owns the profile:
			-- 7) Release profile if it hasn't been released yet: --
			if is_active == true then
				ReleaseProfileInternally(profile)
			end
		end
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1
end

----- Public functions -----

-- GlobalUpdates object:

local GlobalUpdates = {
	--[[
		_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
		_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
		_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
		
		_new_active_update_listeners = {listener, ...} / nil, -- [table / nil]
		_new_locked_update_listeners = {listener, ...} / nil, -- [table / nil]
		
		_profile = Profile / nil, -- [Profile / nil]
		
		_update_handler_mode = true / nil, -- [bool / nil]
	--]]
}
GlobalUpdates.__index = GlobalUpdates

-- ALWAYS PUBLIC:
function GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == false then
			local is_pending_lock = false
			if self._pending_update_lock ~= nil then
				for _, update_id in ipairs(self._pending_update_lock) do
					if global_update[1] == update_id then
						is_pending_lock = true -- Exclude global updates pending to be locked
						break
					end
				end
			end
			if is_pending_lock == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

function GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == true then
			local is_pending_clear = false
			if self._pending_update_clear ~= nil then
				for _, update_id in ipairs(self._pending_update_clear) do
					if global_update[1] == update_id then
						is_pending_clear = true -- Exclude global updates pending to be cleared
						break
					end
				end
			end
			if is_pending_clear == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

-- ONLY WHEN FROM "Profile.GlobalUpdates":
function GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_active_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile._profile_store._loaded_profiles[profile._id] ~= profile then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	table.insert(self._new_active_update_listeners, listener)
	return ScriptConnection.NewScriptConnection(self._new_active_update_listeners, listener)
end

function GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_locked_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile._profile_store._loaded_profiles[profile._id] ~= profile then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	table.insert(self._new_locked_update_listeners, listener)
	return ScriptConnection.NewScriptConnection(self._new_locked_update_listeners, listener)
end

function GlobalUpdates:LockActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_lock == nil then
		error("[ProfileService]: Can't lock active global updates in view mode")
	elseif profile._profile_store._loaded_profiles[profile._id] ~= profile then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't lock active global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_lock = false
		for _, lock_update_id in ipairs(self._pending_update_lock) do
			if update_id == lock_update_id then
				is_pending_lock = true -- Exclude global updates pending to be locked
				break
			end
		end
		if is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock
			table.insert(self._pending_update_lock, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearLockedUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_clear == nil then
		error("[ProfileService]: Can't clear locked global updates in view mode")
	elseif profile._profile_store._loaded_profiles[profile._id] ~= profile then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_clear = false
		for _, clear_update_id in ipairs(self._pending_update_clear) do
			if update_id == clear_update_id then
				is_pending_clear = true -- Exclude global updates pending to be cleared
				break
			end
		end
		if is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear
			table.insert(self._pending_update_clear, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
function GlobalUpdates:AddActiveUpdate(update_data)
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local update_index = updates_latest[1] + 1 -- Incrementing global update index
	updates_latest[1] = update_index
	-- Add new active global update:
	table.insert(updates_latest[2], {update_index, 1, false, update_data})
end

function GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update = nil
	for _, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't change locked global update")
		end
		get_global_update[2] = get_global_update[2] + 1 -- Increment version id
		get_global_update[4] = update_data -- Set new global update data
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id argument")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update_index = nil
	local get_global_update = nil
	for index, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update_index = index
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't clear locked global update")
		end
		table.remove(updates_latest[2], get_global_update_index) -- Remove active global update
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- Profile object:

local Profile = {
	--[[
		Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
		MetaData = {}, -- [table] -- Updated with every auto-save
		GlobalUpdates = GlobalUpdates, -- [GlobalUpdates]
		
		_id = 1 / nil, -- [number / nil]
		_profile_store = ProfileStore, -- [ProfileStore]
		_profile_key = "", -- [string]
		
		_release_listeners = {listener, ...} / nil, -- [table / nil]
		
		_view_mode = true / nil, -- [bool / nil]
	--]]
}
Profile.__index = Profile

function Profile:IsActive() --> [bool]
	return self._profile_store._loaded_profiles[self._id] == self
end

function Profile:GetMetaTag(tag_name) --> value
	local meta_data = self.MetaData
	if meta_data == nil then
		return nil
		-- error("[ProfileService]: This Profile hasn't been loaded before - MetaData not available")
	end
	return self.MetaData.MetaTags[tag_name]
end

function Profile:SetMetaTag(tag_name, value)
	if type(tag_name) ~= "string" then
		error("[ProfileService]: tag_name must be a string")
	elseif string.len(tag_name) == 0 then
		error("[ProfileService]: Invalid tag_name")
	end
	if self._view_mode == true then
		error("[ProfileService]: Can't set meta tag in view mode")
	end
	local is_active = self._profile_store._loaded_profiles[self._id] == self
	if is_active == false then
		error("[ProfileService]: PROFILE EXPIRED - Meta tags can't be set")
	end
	self.MetaData.MetaTags[tag_name] = value
end

function Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id, game_job_id)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()")
	end
	if self._view_mode == true then
		error("[ProfileService]: Can't listen to Profile release in view mode")
	end
	local is_active = self._profile_store._loaded_profiles[self._id] == self
	if is_active == false then
		-- Call release listener immediately if profile is expired
		listener()
		return {
			Disconnect = function() end,
		}
	else
		table.insert(self._release_listeners, listener)
		return ScriptConnection.NewScriptConnection(self._release_listeners, listener)
	end
end

function Profile:Save()
	if self._view_mode == true then
		error("[ProfileService]: Can't save Profile in view mode")
	end
	local is_active = self._profile_store._loaded_profiles[self._id] == self
	if is_active == false then
		error("[ProfileService]: PROFILE EXPIRED - Can't save Profile")
	end
	-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:
	RemoveProfileFromAutoSave(self)
	AddProfileToAutoSave(self)
	-- Call save function in a new thread:
	coroutine.wrap(SaveProfileAsync)(self)
end

function Profile:Release()
	if self._view_mode == true then
		error("[ProfileService]: Can't release Profile in view mode")
	end
	local is_active = self._profile_store._loaded_profiles[self._id] == self
	if is_active == true then
		coroutine.wrap(SaveProfileAsync)(self, true) -- Call save function in a new thread with release_from_session = true
	end
end

-- ProfileStore object:

local ProfileStore = {
	--[[
		_profile_store_name = "", -- [string] -- DataStore name
		_profile_template = {} / nil, -- [table / nil]
		_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
		
		_loaded_profiles = {[profile_id] = Profile, ...}, -- [table] objects
		_profile_load_jobs = {["profile_key"] = {load_id, loaded_data}, ...},
	--]]
}
ProfileStore.__index = ProfileStore

function ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile / nil] not_released_handler(place_id, game_job_id)
	if self._profile_template == nil then
		error("[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore")
	end
	if type(profile_key) ~= "string" then
		error("[ProfileService]: profile_key must be a string")
	elseif string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(not_released_handler) ~= "function" and not_released_handler ~= "ForceLoad" then
		error("[ProfileService]: Invalid not_released_handler")
	end
	
	if ProfileService.ServiceLocked == true then
		return nil
		-- error("[ProfileService]: Can't load Profile when the game is shutting down")
	end
	
	-- Check if profile with profile_key isn't already loaded in this session:
	for _, profile_store in ipairs(ActiveProfileStores) do
		if profile_store._profile_store_name == self._profile_store_name then
			for _, loaded_profile in pairs(profile_store._loaded_profiles) do
				if profile_key == loaded_profile._profile_key then
					error("[ProfileService]: Profile of ProfileStore \"" .. self._profile_store_name .. "\" with key \"" .. profile_key .. "\" is already loaded in this session")
					-- Are you using Profile:Release() properly?
				end
			end
		end
	end
	
	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1
	local force_load = false or (not_released_handler == "ForceLoad")
	local force_load_steps = 0
	local request_force_load = force_load -- First step of ForceLoad
	local steal_session = false -- Second step of ForceLoad
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,
		-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare
		-- game breaking errors where a player rejoins the server super fast.
		local loaded_data
		local load_id = LoadIndex + 1
		LoadIndex = load_id
		local profile_load_job = self._profile_load_jobs[profile_key] -- {load_id, loaded_data}
		if profile_load_job ~= nil then
			profile_load_job[1] = load_id -- Yoink load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked
				loaded_data = profile_load_job[2]
				self._profile_load_jobs[profile_key] = nil
			else
				return nil
			end
		else
			profile_load_job = {load_id, nil}
			self._profile_load_jobs[profile_key] = profile_load_job
			profile_load_job[2] = StandardProfileUpdateAsyncDataStore(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							local force_load_session = latest_data.MetaData.ForceLoadSession
							-- IsThisSession(active_session)
							if active_session == nil then
								latest_data.MetaData.ActiveSession = {PlaceId, JobId}
								latest_data.MetaData.ForceLoadSession = nil
							elseif type(active_session) == "table" then
								if IsThisSession(active_session) == false then
									if steal_session == true then
										local force_load_uninterrupted = false
										if force_load_session ~= nil then
											force_load_uninterrupted = IsThisSession(force_load_session)
										end
										if force_load_uninterrupted == true then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
										end
									elseif request_force_load == true then
										latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
									end
								else
									latest_data.MetaData.ForceLoadSession = nil
								end
							end
						end
					end,
					MissingProfileHandle = function(latest_data)
						latest_data.Data = DeepCopyTable(self._profile_template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = {PlaceId, JobId},
							ForceLoadSession = nil,
							MetaTags = {},
						}
					end,
					EditProfile = function(latest_data)
						latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
					end,
				})
			if profile_load_job[1] == load_id then -- Load job hasn't been yoinked
				loaded_data = profile_load_job[2]
				self._profile_load_jobs[profile_key] = nil
			else
				return nil -- Load job yoinked
			end
		end
		-- Handle load_data:
		if loaded_data ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then
				if IsThisSession(active_session) == true then
					-- Special component in MetaTags:
					loaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)
					-- Case #1: Profile is now taken by this session:
					-- Create Profile object:
					ProfileIndex = ProfileIndex + 1
					local global_updates_object = {
						_updates_latest = loaded_data.GlobalUpdates,
						_pending_update_lock = {},
						_pending_update_clear = {},
						
						_new_active_update_listeners = {},
						_new_locked_update_listeners = {},
						
						_profile = nil,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					local profile = {
						Data = loaded_data.Data,
						MetaData = loaded_data.MetaData,
						GlobalUpdates = global_updates_object,
						
						_id = ProfileIndex,
						_profile_store = self,
						_profile_key = profile_key,
						
						_release_listeners = {},
						
						_load_timestamp = tick(),
					}
					setmetatable(profile, Profile)
					global_updates_object._profile = profile
					-- Referencing Profile object in ProfileStore:
					if next(self._loaded_profiles) == nil then -- ProfileStore object was inactive
						table.insert(ActiveProfileStores, self)
					end
					self._loaded_profiles[ProfileIndex] = profile
					-- Adding profile to AutoSaveList;
					AddProfileToAutoSave(profile)
					-- Special case - finished loading profile, but session is shutting down:
					if ProfileService.ServiceLocked == true then
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- nil will be returned by this call
					end
					-- Return Profile object:
					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile
				else
					-- Case #2: Profile is taken by some other session:
					if force_load == true then
						local force_load_session = loaded_data.MetaData.ForceLoadSession
						local force_load_uninterrupted = false
						if force_load_session ~= nil then
							force_load_uninterrupted = IsThisSession(force_load_session)
						end
						if force_load_uninterrupted == true then
							if request_force_load == false then
								force_load_steps = force_load_steps + 1
								if force_load_steps == SETTINGS.ForceLoadMaxSteps then
									steal_session = true
								end
							end
							wait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
						else
							-- Another session tried to force load this profile:
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						end
						request_force_load = false -- Only request a force load once
					else
						local handler_result = not_released_handler(active_session[1], active_session[2])
						if handler_result == "Repeat" then
							wait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
						elseif handler_result == "Cancel" then
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						elseif handler_result == "ForceLoad" then
							force_load = true
							request_force_load = true
							wait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
						else
							error("[ProfileService]: Invalid return from not_released_handler")
						end
					end
				end
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				error("[ProfileService]: Invalid ActiveSession value in Profile.MetaData - Fatal corruption") -- It's unlikely this will ever fire
			end
		else
			wait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
		end
	end
	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- If loop breaks return nothing
end

function ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(update_handler) ~= "function" then
		error("[ProfileService]: Invalid update_handler")
	end
	
	if ProfileService.ServiceLocked == true then
		return nil
		-- error("[ProfileService]: Can't global update Profile when the game is shutting down")
	end
	
	while ProfileService.ServiceLocked == false do
		-- Updating profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)
					-- Running update_handler:
					local global_updates_object = {
						_updates_latest = latest_data.GlobalUpdates,
						_update_handler_mode = true,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					update_handler(global_updates_object)
				end,
			})
		-- Handling loaded_data:
		if loaded_data ~= nil then
			-- Return GlobalUpdates object (Update successful):
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			return global_updates_object
		else
			wait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again
		end
	end
	return nil -- Return nothing (Update unsuccessful)
end
		
function ProfileStore:ViewProfileAsync(profile_key) --> [Profile / nil]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	
	if ProfileService.ServiceLocked == true then
		return nil
		-- error("[ProfileService]: Can't view Profile when the game is shutting down")
	end
	
	local force_load = false
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = nil,
			})
		-- Handle load_data:
		if loaded_data ~= nil then
			-- Create Profile object:
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
				_profile = nil,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			local profile = {
				Data = loaded_data.Data,
				MetaData = loaded_data.MetaData,
				GlobalUpdates = global_updates_object,
				
				_id = nil,
				_profile_store = self,
				_profile_key = profile_key,
				
				_view_mode = true,
				
				_load_timestamp = tick(),
			}
			setmetatable(profile, Profile)
			global_updates_object._profile = profile
			-- Returning Profile object:
			return profile
		else
			wait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
		end
	end
	return nil -- If loop breaks return nothing
end

-- New ProfileStore:

function ProfileService.GetProfileStore(profile_store_name, profile_template) --> [ProfileStore]
	if type(profile_store_name) ~= "string" then
		error("[ProfileService]: profile_store_name must be a string")
	elseif string.len(profile_store_name) == 0 then
		error("[ProfileService]: Invalid profile_store_name")
	end
	
	if type(profile_template) ~= "table" then
		error("[ProfileService]: Invalid profile_template")
	end
	
	local profile_store = {
		_profile_store_name = profile_store_name,
		_profile_template = profile_template,
		_global_data_store = nil,
		_loaded_profiles = {},
		_profile_load_jobs = {},
	}
	if IsStudio == false then
		profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name)
	end
	setmetatable(profile_store, ProfileStore)
	return profile_store
end

----- Initialize -----

ProfileService.IssueSignal = ScriptSignal.NewScriptSignal()
ProfileService.CorruptionSignal = ScriptSignal.NewScriptSignal()
ProfileService.CriticalStateSignal = ScriptSignal.NewScriptSignal()

if IsStudio == true then
	FakeDataStore = _G.FakeDataStore
	if FakeDataStore == nil then
		FakeDataStore = {}
		_G.FakeDataStore = FakeDataStore
	end
end

----- Connections -----

-- Auto saving and issue queue managing:
RunService.Heartbeat:Connect(function()
	-- 1) Auto saving: --
	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length
		local current_tick = tick()
		while current_tick - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if current_tick - profile._load_timestamp < SETTINGS.AutoSaveProfiles then
				-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:
				profile = nil
				for i = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if current_tick - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			-- print("[ProfileService]: Auto updating profile - profile_store_name = \"" .. profile._profile_store._profile_store_name .. "\"; profile_key = \"" .. profile._profile_key .. "\"")
			if profile ~= nil then
				coroutine.wrap(SaveProfileAsync)(profile) -- Auto save profile in new thread
			end
		end
	end
	-- 2) Issue queue: --
	-- Critical state handling:
	if ProfileService.CriticalState == false then
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			ProfileService.CriticalState = true
			ProfileService.CriticalStateSignal:Fire(true)
			CriticalStateStart = tick()
			warn("[ProfileService]: Entered critical state")
		end
	else
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			CriticalStateStart = tick()
		elseif tick() - CriticalStateStart > SETTINGS.CriticalStateLast then
			ProfileService.CriticalState = false
			ProfileService.CriticalStateSignal:Fire(false)
			warn("[ProfileService]: Critical state ended")
		end
	end
	-- Issue queue:
	while true do
		local issue_tick = IssueQueue[1]
		if issue_tick == nil then
			break
		elseif tick() - issue_tick > SETTINGS.IssueLast then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end
end)

-- Release all loaded profiles when the server is shutting down:
game:BindToClose(function()
	if IsStudio == true then
		return -- Ignores OnCloseTasks if game is running inside Roblox Studio
	end
	ProfileService.ServiceLocked = true
	-- 1) Release all active profiles: --
	-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:
	local on_close_save_job_count = 0
	local active_profiles = {}
	for index, profile in ipairs(AutoSaveList) do
		active_profiles[index] = profile
	end
	-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
	for _, profile in ipairs(active_profiles) do
		local is_active = profile._profile_store._loaded_profiles[profile._id] == profile
		if is_active then
			on_close_save_job_count = on_close_save_job_count + 1
			coroutine.wrap(function() -- Save profile on new thread
				SaveProfileAsync(profile, true)
				on_close_save_job_count = on_close_save_job_count - 1
			end)()
		end
	end
	-- 2) Yield until all active profile jobs are finished: --
	while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
		RunService.Heartbeat:Wait()
	end
	return -- We're done!
end)

return ProfileService]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">HelperFns</string>
				<string name="ScriptGuid">{28CD75A2-4659-4E9E-8028-E9F078DD3BC9}</string>
				<ProtectedString name="Source"><![CDATA[local HelperFns = {}

wait()
for _,func in pairs(script:GetChildren()) do
	HelperFns[func.Name] = require(func)
end

return HelperFns]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="10">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Remotes</string>
				<string name="ScriptGuid">{CC53B780-5DD3-40EB-B3F2-73C37F530C29}</string>
				<ProtectedString name="Source"><![CDATA[local Remotes = {}

wait()
for _,remote in pairs(script:GetChildren()) do
	Remotes[remote.Name] = remote
end

return Remotes]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="RemoteEvent" referent="11">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">TestEv</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="RemoteFunction" referent="12">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">TestFn</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="RemoteEvent" referent="RBX1BAE4A5083EC4D56BFDEF1E8071B51BB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">UpdatePlayerDataEv</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="RemoteFunction" referent="RBX61CFAD285C53408ABEB9EF988DCB1B27">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">GetAllPlayerDataFn</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX193A827310274FECB3ACF41F94C997F2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Lighting" referent="1">
		<Properties>
			<Color3 name="Ambient">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">2</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.5</float>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
		</Properties>
	</Item>
	<Item class="HttpService" referent="0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX64893DD18D6A43828B54E5E899CCEB48">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>